#+TITLE: Literate Configuration

* Prelude

  This is the beginning of a "literate" emacs configuration. This is both a way
  to learn more about ~org-mode~ and to better organize my configuration.

  So far I am very impressed with how it feels to write code like this. Logical
  and explicitly-named code-folding, with first class comments and
  hyperlinks, seems disproportionately useful and powerful.

* Look & Feel

  First things first, let's make emacs pretty.

  #+name: look-and-feel
  #+BEGIN_SRC emacs-lisp
    (load-theme 'tango-dark)

    (blink-cursor-mode 0)
    (setq initial-scratch-message "")
    (setq inhibit-startup-message t)
    (setq inhibit-startup-echo-area-message "isaachodes")
    (menu-bar-mode -1)
    (tool-bar-mode -1)
    (scroll-bar-mode -1)

    (show-paren-mode 1)
    (set-face-attribute 'mode-line nil
                        :foreground "gray100" :background "gray10"
                        :inverse-video nil
                        :box '(:line-width 6 :color "gray20" :style nil))
    (set-face-attribute 'mode-line-inactive nil
                        :foreground "gray30" :background "gray10"
                        :inverse-video nil
                        :box '(:line-width 6 :color "gray10" :style nil))
  #+END_SRC
* Packages

  Configure and load ~cask.el~, initializing the packages it manages [[file:Cask][Cask]].

  #+name: packages
  #+BEGIN_SRC emacs-lisp
    (require 'cask "/usr/local/Cellar/cask/0.7.2/cask.el")
    (cask-initialize)
  #+END_SRC

  ([[https://github.com/cask/cask][Cask]] can be installed with ~brew install cask~, and the packages managed by
  the Cask file can be installed with ~cask install~.)

* Defaults

  Here we set some defaults which generally make emacs a more well-behaved
  editor.

  #+name: defaults
  #+BEGIN_SRC emacs-lisp
    (global-undo-tree-mode)
    (column-number-mode t)
    (setq kill-ring-max 500)
    (setq js-indent-level 2)
    (setq tramp-default-method "ssh")
    (setq auto-save-default nil)

    (windmove-default-keybindings)

    (require 'uniquify)
    (setq-default uniquify-buffer-name-style 'forward)

    (require 'saveplace)
    (setq-default save-place t
                  save-place-file (concat user-emacs-directory "places"))

    (setq-default indent-tabs-mode nil
                  fill-column 80
                  show-trailing-whitespace t
                  auto-save-file-name-transforms `((".*" ,temporary-file-directory t))
                  enable-recursive-minibuffers t
                  apropos-do-all t
                  backup-directory-alist `(("." . ,(concat user-emacs-directory
                                                   "backups"))))
  #+END_SRC
* Modes

  Here we activate modes and do a lot of stuff which should be split out into
  smaller code blocks.

  We load and configure all packages with the glorious [[https://github.com/jwiegley/use-package][use-package]] mode.

  #+name: modes
  #+BEGIN_SRC emacs-lisp
    (require 'use-package)
  #+END_SRC

  And configure most of them...

  #+name: modes
  #+BEGIN_SRC emacs-lisp
    (use-package ido
      :init
      (ido-mode 1)
      (setq ido-enable-flex-matching t
          ido-everywhere t
          ido-use-faces nil ;; disable ido faces to see flx highlights.
          ido-create-new-buffer 'always
          ido-use-filename-at-point 'guess
          ido-enable-flex-matching t)
      (use-package ido-ubiquitous
        :ensure ido-ubiquitous
        :init
        (ido-ubiquitous-mode 1))
      (use-package ido-vertical-mode
        :ensure ido-vertical-mode
        :init
        (ido-vertical-mode))
      (use-package flx-ido
        :ensure flx-ido
        :init
        (setq flx-ido-threshold 1000)
        (flx-ido-mode 1))
      :bind
      ("<f4>" . ido-recentf-open)
      ("C-x C-d" . ido-dired))

    (use-package smex
      :ensure smex
      :bind ("M-x" . smex)
      :init
      (unbind-key "M-x")
      (unbind-key "<menu>")
      (smex-initialize))

    (use-package fycheck
      :init
      (add-hook 'after-init-hook 'global-flycheck-mode)
      (flycheck-define-checker jsxhint-checker
        "A JSX syntax and style checker based on JSXHint."
        :command ("jsxhint" (config-file "--config=" jshint-configuration-path) source)
        :error-patterns ((error line-start (1+ nonl)
                                ": line " line
                                ", col " column
                                ", " (message)
                                line-end))
        :modes (js-mode))
      (setq auto-mode-alist (remove (rassoc 'html-mode auto-mode-alist)
                                    auto-mode-alist)))

    (use-package ace-jump-mode
      :bind ("M-SPC" . ace-jump-mode))

    (use-package paredit
      :init
      (dolist (x '(scheme emacs-lisp lisp clojure))
        (add-hook
         (intern (concat (symbol-name x) "-mode-hook")) 'paredit-mode)))

    (use-package web-mode
      :mode (("\\.phtml\\'" . web-mode)
             ("\\.jsx\\'" . web-mode)
             ("\\.tpl\\.php\\'" . web-mode)
             ("\\.jsp\\'" . web-mode)
             ("\\.as[cp]x\\'" . web-mode)
             ("\\.erb\\'" . web-mode)
             ("\\.ejs\\'" . web-mode)
             ("\\.mustache\\'" . web-mode)
             ("\\.djhtml\\'" . web-mode)
             ("\\.html?\\'" . web-mode)
             ("\\.css?\\'" . web-mode))
      :config
      (setq web-mode-markup-indent-offset 2
            web-mode-css-indent-offset 2
            web-mode-engines-alist '(("erb" . "\\.ejs\\'")))

      (bind-keys :map web-mode-map ("C-c /" . web-mode-element-close)))

    (use-package smart-mode-line
      :init
      (setq sml/no-confirm-load-theme t)
      (sml/setup)
      (sml/apply-theme 'dark)
      (add-to-list 'sml/replacer-regexp-list '("^~/workspace/" ":W:") t)
      (add-to-list 'sml/hidden-modes " Undo-Tree")
      (add-to-list 'sml/hidden-modes " MRev")
      (add-to-list 'sml/hidden-modes " Paredit")
      (add-to-list 'sml/hidden-modes " hl-s")
      (add-to-list 'sml/hidden-modes " Helm")
      (add-to-list 'sml/hidden-modes " company")
      (add-to-list 'sml/hidden-modes " yas"))

    (use-package company
      :init
      (global-company-mode t)
      (add-to-list 'company-backends 'company-anaconda))

    (use-package ag
      :bind ("<f2>" . ag-project)
      :init (setq ag-highlight-search t))

    (use-package recentf
      :init
      (recentf-mode t)
      (setq recentf-max-saved-items 50))

    (use-package expand-region
      :bind (("s-=" . er/expand-region)
             ("s--" . er/contract-region)))

    (use-package visual-regexp
      :bind (("C-c q" . vr/query-replace)
             ("C-c r" . vr/replace)
             ("s-c" . vr/mc-mark)))

    (use-package browse-kill-ring
      :bind ("C-M-y" . browse-kill-ring))

    (use-package undo-tree-mode
      :bind (("C-x C-u" . undo-tree-undo)
             ("C-x C-r" . undo-tree-redo)))

    (use-package haskell-mode
      :init
      (add-hook 'haskell-mode-hook 'turn-on-haskell-indentation))

    (use-package magit
      :bind ("C-x g" . magit-status)
      :config
      (defadvice magit-status (around magit-fullscreen activate)
        (window-configuration-to-register :magit-fullscreen)
        ad-do-it
        (delete-other-windows))

      (defun magit-quit-session ()
        "Restores the previous window configuration and kills the magit buffer"
        (interactive)
        (kill-buffer)
        (jump-to-register :magit-fullscreen))

      (bind-keys :map magit-status-mode-map
                 ("q" . magit-quit-session)))

    (use-package projectile
      :bind ("s-p" . projectile-commander)
      :init
      (progn
        (projectile-global-mode)
        (setq projectile-mode-line
              '(:eval (format " @:%s" (projectile-project-name))))))

    (use-package rainbow-delimiters
      :init
      (add-hook 'prog-mode-hook 'rainbow-delimiters-mode))

    (use-package yasnippet
      :init
      (progn
        (setq yas-snippet-dirs '("~/.emacs.d/snippets"))
        (yas-global-mode 1)))

  #+END_SRC

  Finally we quick'n'dirtily set some little text modes.

  #+name: modes
  #+BEGIN_SRC emacs-lisp
    (defvar ihodes/text-modes
      '(("\\.avpr?\\'" . js-mode)
        ("\\.avdl?\\'" . c-mode)
        ("\\.yml\\'" . yaml-mode)
        ("\\.markdown\\'" . markdown-mode)
        ("\\.md\\'" . markdown-mode)))

    (dolist (mm ihodes/text-modes)
      (add-to-list 'auto-mode-alist mm))
  #+END_SRC

  (And some misc. additional code...)

  #+name: modes
  #+BEGIN_SRC emacs-lisp
    ;; https://github.com/purcell/exec-path-from-shell
    (when (memq window-system '(mac ns))
      (exec-path-from-shell-initialize))

    (add-hook 'sql-interactive-mode-hook '(lambda () (toggle-truncate-lines t)))
  #+END_SRC

** Org

Very rudimentary customization of ~org-mode~.

Primarily we set our [[http://mobileorg.ncogni.to/][MobileOrg]] directory so that we can sync with the iPhone (or
Android!) app. We also enable support for a variety of languages.

#+name: org
#+BEGIN_SRC emacs-lisp
  (bind-key "C-c c" 'org-capture)
  (bind-key "C-c a" 'org-agenda)

  (setq org-directory "~/org/")
  (setq org-default-notes-file "~/org/notes.org")
  (setq org-mobile-directory "~/Dropbox/Apps/MobileOrg")

  (org-babel-do-load-languages
   (quote org-babel-load-languages)
   (quote ((emacs-lisp . t)
           (ditaa . t)
           (dot . t)
           (clojure . t)
           (js . t)
           (R . t)
           (python . t)
           (ruby . t)
           (sh . t)
           (ledger . t)
           (org . t)
           (latex . t))))
  (setq org-src-fontify-natively nil)

  (setq org-modules '(org-info
                      org-habit))

  (org-load-modules-maybe t)
#+END_SRC

We need to unbind ~S-<left|right|up|down>~ because ~org-mode~ steals these from
~windmove~, which is not cool.

#+name: modes
#+BEGIN_SRC emacs-lisp
  (dolist (dir '("left" "right" "up" "down"))
    (define-key org-mode-map (kbd (format "S-<%s>" dir)) nil))
#+END_SRC
** Python settings

This lets us use the iPython kernel as the inferior Python process.

  #+name: modes
  #+BEGIN_SRC emacs-lisp
    (setq python-shell-interpreter "ipython"
          python-shell-prompt-regexp "In \\[[0-9]+\\]: "
          python-shell-prompt-output-regexp "Out \\[[0-9]+\\]: "
          python-shell-completion-setup-code
          "from IPython.core.completerlib import module_completion"
          python-shell-completion-module-string-code
          "';'.join(module_completion('''%s'''))\n"
          python-shell-completion-string-code
          "';'.join(get_ipython().Completer.all_completions('''%s'''))\n")
  #+END_SRC

Some simple EIN customizations.

  #+name: modes
  #+BEGIN_SRC emacs-lisp
    (setq ein:use-auto-complete 1)
    (setq ein:console-args '("--gui=osx" "--matplotlib=osx" "--colors=Linux"))

    (defun ein:load-notebooks ()
      (interactive)
      (ein:notebooklist-load)
      (ein:notebooklist-open))
  #+END_SRC
** Clojure settings

Clojure-mode is useful for ~.edn~, ~.cljs~, and ~.cljx~ files as well.

  #+name: modes
  #+BEGIN_SRC emacs-lisp
    (nconc auto-mode-alist '(("\\.edn\\'" . clojure-mode)
                             ("\\.cljs\\'" . clojure-mode)
                             ("\\.cljx\\'" . clojure-mode)))
  #+END_SRC

We make the [[https://github.com/clojure-emacs/cider][Cider]] (Clojure IDE) experience a bit better.

  #+name: modes
  #+BEGIN_SRC emacs-lisp
    (require 'clojure-mode)
    (add-hook 'cider-mode-hook 'cider-turn-on-eldoc-mode)
    (add-hook 'cider-repl-mode-hook 'paredit-mode)
    (setq nrepl-hide-special-buffers t)
    (setq cider-auto-select-error-buffer t)
  #+END_SRC

Some common Clojure functions look better with different indentation, so we set
those here.

  #+name: modes
  #+BEGIN_SRC emacs-lisp
    (define-clojure-indent
      (defroutes 'defun)
      (GET 2)
      (POST 2)
      (PUT 2)
      (DELETE 2)
      (HEAD 2)
      (ANY 2)
      (context 2)
      (form-to 1)
      (match 1)
      (are 2)
      (select 1)
      (insert 1)
      (update 1)
      (delete 1)
      (run* 1)
      (fresh 1)
      (extend-freeze 2)
      (extend-thaw 1))
  #+END_SRC
** Scala settings

   #+name: modes
   #+BEGIN_SRC emacs-lisp
     (use-package ensime
       :init
       (progn
         (add-hook 'scala-mode-hook 'ensime-scala-mode-hook)
         (setq ensime-sem-high-faces
               '((var . (:foreground "#ff2222"))
                 (val . (:foreground "#dddddd"))
                 (varField . (:foreground "#ff3333"))
                 (valField . (:foreground "#dddddd"))
                 (functionCall . (:foreground "#84BEE3"))
                 (param . (:foreground "#ffffff"))
                 (class . font-lock-type-face)
                 (trait . (:foreground "#084EA8"))
                 (object . (:foreground "#026DF7"))
                 (package . font-lock-preprocessor-face)))))
   #+END_SRC
** Coq
   #+name: modes
   #+BEGIN_SRC emacs-lisp
     (load-file "/usr/local/share/emacs/site-lisp/ProofGeneral/generic/proof-site.el")
     (autoload 'coq-mode "coq" "Major mode for editing Coq vernacular." t)
     (setq auto-mode-alist (cons '("\\.v$" . coq-mode) auto-mode-alist))
     (eval-after-load 'coq-mode '(define-key coq-mode-map (kbd "C-c C-.") 'proof-goto-point))
   #+END_SRC
* Gittit
  ~gittit~ is a little library I wrote to connect local files to GitHub repos.

  These are our utility functions.

  #+name: gittit
  #+BEGIN_SRC emacs-lisp
    (defun gittit:base-github-url ()
      (let* ((git-url (shell-command-to-string "git config --get remote.origin.url"))
             (http-url (replace-regexp-in-string "git@" "" git-url))
             (http-url (replace-regexp-in-string "\.git" "" http-url))
             (http-url (replace-regexp-in-string ":" "/" http-url))
             (http-url (replace-regexp-in-string "\n" "" http-url)))
        http-url))

    (defun gittit:current-branch-name ()
      (replace-regexp-in-string "\n" "" (shell-command-to-string "git rev-parse --abbrev-ref HEAD")))

    (defun gittit:parent-directory (dir)
      (unless (equal "/" dir)
        (file-name-directory (directory-file-name dir))))

    (defun gittit:base-git-directory (filename)
      (let ((base-dir (file-name-directory filename)))
        (if (file-exists-p (concat base-dir ".git"))
          base-dir
          (gittit:base-git-directory (gittit:parent-directory base-dir)))))

    (defun gittit:github-url-for-file (filename)
      (format "http://%s/blob/%s/%s"
              (gittit:base-github-url)
              (gittit:current-branch-name)
              (replace-regexp-in-string (gittit:base-git-directory filename) "" filename)))

    (defun gittit:github-url-for-line (filename start &optional end)
      (format (concat (gittit:github-url-for-file filename) (if end "#L%s-L%s" "#L%s"))
              start
              end))
  #+END_SRC

  These are the public exports:

  #+name: gittit
  #+BEGIN_SRC emacs-lisp
    (defun github-url-for-line  (filename start &optional end)
      "Returns, echoes, and kills the GitHub URL for FILENAME between START and optionally END."
      (interactive (cons (buffer-file-name)
                         (if (use-region-p)
                            (list (region-beginning) (region-end))
                            (list (point)))))
      (let* ((url (gittit:github-url-for-file filename))
             (start-line (1+ (count-lines 1 start)))
             (url (if end
                      (format "%s#L%s-L%s" url start-line (count-lines 1 end))
                      (format "%s#L%s" url start-line))))
        (kill-new url)
        (message url)
        url))

    (defun browse-github-url-for-line (filename start &optional end)
      "Navigate to the GitHub URL for FILENAME between START and optionally END."
      (interactive (cons (buffer-file-name)
                         (if (use-region-p)
                            (list (region-beginning) (region-end))
                            (list (point)))))
      (browse-url (if end (github-url-for-line filename start end)
                    (github-url-for-line filename start))))
  #+END_SRC

  Under the [[http://www.apache.org/licenses/LICENSE-2.0.html][Apache 2.0 License]].
* Misc. Functions
  A bunch of little utility functions created here and elsewhere.
  #+name: functions
  #+BEGIN_SRC emacs-lisp
    (defun clear-shell-buffer ()
      "Clear the current buffer"
      (interactive)
      (let ((comint-buffer-maximum-size 0))
         (comint-truncate-buffer)))

    (defun osx:copy-region (start end)
      "Copy the region to OSX's clipboard."
      (interactive (list (region-beginning) (region-end)))
      (shell-command-on-region start end "pbcopy")
      (message "Copied to OSX clipboard!"))

    (defun osx:paste ()
      "Copy the region to OSX's clipboard."
      (interactive)
      (insert (shell-command-to-string "pbpaste"))
      (message "Pasted from OSX clipboard!"))

    (defun osx:copy-kill ()
      "Copy the current kill text to OSX's clipboard."
      (interactive)
      (with-temp-buffer
        (yank)
        (shell-command-on-region 1 (point-max) "pbcopy")))

    (defun set-exec-path-from-shell-PATH ()
      (let ((path-from-shell (replace-regexp-in-string
                              "[ \t\n]*$"
                              ""
                              (shell-command-to-string "$SHELL --login -i -c 'echo $PATH'"))))
        (setenv "PATH" path-from-shell)
        (setq eshell-path-env path-from-shell) ; for eshell users
        (setq exec-path (split-string path-from-shell path-separator))))

    ;;http://emacsredux.com/blog/2013/05/22/smarter-navigation-to-the-beginning-of-a-line/
    (defun smarter-move-beginning-of-line (arg)
      "Move point back to indentation of beginning of line.

    Move point to the first non-whitespace character on this line.
    If point is already there, move to the beginning of the line.
    Effectively toggle between the first non-whitespace character and
    the beginning of the line.

    If ARG is not nil or 1, move forward ARG - 1 lines first.  If
    point reaches the beginning or end of the buffer, stop there."
      (interactive "^p")
      (setq arg (or arg 1))

      ;; Move lines first
      (when (/= arg 1)
        (let ((line-move-visual nil))
          (forward-line (1- arg))))

      (let ((orig-point (point)))
        (back-to-indentation)
        (when (= orig-point (point))
          (move-beginning-of-line 1))))

    (defun endless/load-gh-pulls-mode ()
      "Start `magit-gh-pulls-mode' only after a manual request."
      (interactive)
      (require 'magit-gh-pulls)
      (add-hook 'magit-mode-hook 'turn-on-magit-gh-pulls)
      (magit-gh-pulls-mode 1)
      (magit-gh-pulls-reload))

  #+END_SRC
* Bindings

  Global and some mode-specific bindings that need to be cleaned up.

  #+name: bindings
  #+BEGIN_SRC emacs-lisp
    (bind-keys ("<f1>" . eshell)
               ("<f3>" . #'occur)
               ("<f5>" . #'highlight-symbol-at-point)
               ("<f6>" . #'revert-this-buffer)
               ("C-c M-w" . #'whitespace-mode)
               ("M-j" . '(lambda () (interactive) (join-line -1)))
               ("C-x t" . '(lambda () (interactive) (insert "TODO(ihodes): ")))
               ("M-s-≥" . #'mc/mark-next-lines)
               ("C-x w" . #'delete-trailing-whitespace)
               ("C-x C-d" . #'ido-dired)
               ("C-c C-e" . #'eval-buffer)
               ("C-x C-b" . 'ibuffer)
               ("C-s" . #'isearch-forward-regexp)
               ("C-r" . #'isearch-backward-regexp))

    (define-key 'help-command "A" #'apropos) ;; (C-h a)

    (eval-after-load #'comint-mode-hook
      '(progn
         (define-key comint-mode-map (kbd "C-c C-t") 'comint-truncate-buffer)))

    ;; remap C-a to `smarter-move-beginning-of-line'
    (global-set-key [remap move-beginning-of-line]
                    'smarter-move-beginning-of-line)

    (eval-after-load 'js
      '(progn
         (define-key js-mode-map (kbd "C-x ;")
           (lambda ()
             (interactive)
             (insert "console.log();")
             (backward-char 2)))))

    (defun revert-this-buffer ()
      (interactive)
      (revert-buffer nil t t)
      (message (concat "Reverted buffer " (buffer-name))))

    (defun ido-recentf-open ()
      "Use `ido-completing-read' to \\[find-file] a recent file"
      (interactive)
      (if (find-file (ido-completing-read "Find recent file: " recentf-list))
          (message "Opening file...")
        (message "Aborting")))
  #+END_SRC
* Projects

This is a simple & hacky way to start asynchronous processes associated with
projects I frequently work on.

** TODO Manage a list of processes per project, and commands for restarting them etc. Upstart?
** CycleDash
  Found on [[https://github.com/hammerlab/cycledash][GitHub]].
  #+name: projects
  #+BEGIN_SRC emacs-lisp
    (defun cycledash:start-server ()
      "Start the CycleDash server."
      (interactive)
      (async-shell-command "cd ~/workspace/cycledash/ && source venv/bin/activate && ./run.sh"
                           "*CycleDash:./run.sh*"))

    (defun cycledash:start-worker ()
      "Start a CycleDash worker named WORK."
      (interactive)
      (async-shell-command "cd ~/workspace/cycledash/ && source venv/bin/activate && ./worker.sh WORK"
                           "*CycleDash:./worker.sh*"))

    (defun cycledash:start-gulp ()
      "Start the gulp dev js builder."
      (interactive)
      (async-shell-command "cd ~/workspace/cycledash/ && gulp"
                           "*CycleDash: gulp*"))

    (defun cycledash:start ()
      "Start all cycledash services"
      (interactive)
      (dolist (start '(cycledash:start-server cycledash:start-worker cycledash:start-gulp))
        (funcall start)))
  #+END_SRC
** VCF.js
  Found on [[https://github.com/ihodes/vcf.js][GitHub]].
  #+name: projects
  #+BEGIN_SRC emacs-lisp
    (defun vcf-js:test ()
      "Run the vcf test suite"
      (interactive)
      (async-shell-command "cd ~/workspace/vcf.js/ && mocha test/test.js"
                           "*vcf.js: tests*"))

    (defun vcf-js:server ()
      "Run the vcf test server"
      (interactive)
      (async-shell-command "cd ~/workspace/vcf.js/ && http-server"
                           "*vcf.js: server*"))
  #+END_SRC
** Idiogrammatik.js

   Found on [[https://github.com/hammerlab/idiogrammatik][GitHub]].

   #+name: projects
   #+BEGIN_SRC emacs-lisp
    (defun idiogrammatik:server ()
      "Run the idiogrammatik server"
      (interactive)
      (async-shell-command "cd ~/workspace/idiogrammatik/ && http-server -p 8989"
                           "*idiogrammatik: server*"))
   #+END_SRC
* Configuration file layout

  Here I define the ~emacs.el~ file generated by the code in this org file.

  The below block describes how the code above should be organized within the
  generated ~emacs.el~.

  #+BEGIN_SRC emacs-lisp :tangle yes :noweb no-export :exports code
    ;;;; This file generated from `emacs.org` in this directory.

    <<init>>
    <<look-and-feel>>
    <<packages>>
    <<modes>>
    <<defaults>>
    <<functions>>
    <<gittit>>
    <<bindings>>
    <<projects>>
  #+END_SRC

* Archived
